Неупорядоченные (или маркированные) списки создаются с помощью тега <ul>, 
который может содержать внутри себя теги <li>, обозначающие «элемент списка».
Упорядоченный список создаётся с помощью тега <ol>, который может содержать внутри себя теги <li>.
Для упорядоченного списка можно задать атрибут start, который изменяет начало нумерации. Например, код:

<ol start="3">
  <li>раз</li>
  <li>два</li>
</ol>

Создать многоуровневый список достаточно просто.
Сначала нужно создать список первого уровня, а затем внутрь любого элемента этого списка, между тегами <li> и </li>, 
добавить список второго уровня. При этом необходимо аккуратно закрывать все теги.
Количество уровней в списках не ограничено. В многоуровневом списке можно использовать как упорядоченные,
так и неупорядоченные списки.

Список определений создаётся с помощью трёх тегов:

<dl> обозначает сам список определений;
<dt> обозначает термин;
<dd> обозначает определение термина.
Теги <dt> и <dd> пишутся парами внутри <dl>.

Например:

<dl>
  <dt>Термин</dt>
  <dd>Определение</dd>

  <dt>Второй термин</dt>
  <dd>И его определение</dd>

  <dt>Кошка</dt>
  <dd>Шерстяное изделие развлекательного характера</dd>
</dl>

Тег <strong> определяет важность отмеченного текста.

Тег <b> предназначен для выделения текста без придания ему особой важности.
 Когда они включают функцию чтения текста, то «говорилка» будет интонацией выделять слова с тегом <strong>. 
 То же самое касается и тегов <em> и <i>. Тег <em> «говорилка» будет выделять интонацией.
Визуально оба тега одинаковы, они выделяют текст полужирным.


Тег <em> определяет текст, на который сделан особый акцент, меняющий смысл предложения.
Например, если мы хотим подчеркнуть, что Кекс не любит питаться укропом (он больше за тунца), а любит только гонять его по полу, то разметим текст так:
Инструктор Кекс любит <em>играть</em> с укропом.

Тег <i> обозначает текст, который отличается от окружающего текста, но не является более важным.
 Обычно так выделяют названия, термины, иностранные слова.
 
 Одиночный тег <hr> используется для того, чтобы создать горизонтальную линию-разделитель. На внешний вид этой линии можно влиять с помощью атрибутов, 
 но правильней делать это с помощью CSS (это будет изучаться в последующих курсах).
 
 Иногда возникает необходимость вставить в текст перенос строки, не создавая при этом абзац. Например, при разметке стихов или текстов песен.
Для этого в HTML предусмотрен одиночный тег <br>.
 
 В HTML существует несколько тегов для обозначения цитат:
 <blockquote> предназначен для выделения длинных цитат, которые могут состоять из нескольких абзацев. Тег выделяет цитату как отдельный блок текста с отступами.
<q> предназначен для выделения коротких цитат в тексте предложения. Текст внутри этого тега автоматически обрамляется кавычками.
<cite> используется для того, чтобы выделить источник цитаты, название произведения или автора цитаты.

Тег <sup> отображает текст в виде верхнего индекса.

Тег <sub> отображает текст в виде нижнего индекса.

Если вам нужно вставить очень сложную формулу в HTML-документ, лучше воспользоваться специальным языком разметки MathML.

Как раз для описания изменений предназначены теги <del> и <ins>.
<del> выделяет текст, который был удалён в новой версии документа.
<ins> выделяет текст, который был добавлен в новой версии документа.
Оба тега имеют атрибут datetime, в котором можно указать дату и время, когда была внесена та или иная правка.

Изменить это поведение браузера можно с помощью тега <pre>, который обозначает «предварительно отформатированный текст». 
Браузер сохраняет и отображает все пробелы и переносы, которые есть внутри тега <pre>.

Иногда при работе с объёмными текстами мы используем маркер, чтобы выделять ключевые слова, идеи или что-то другое на что стоит обратить внимание. 
Такое же назначение и у тега <mark>.


Ссылки создаются с помощью очень простого и короткого тега <a>. Например, вот так:
<a href="https://htmlacademy.ru">HTML Academy</a>

Абсолютные адреса содержат в себе протокол, имя сервера и путь. Например, в адресе https://htmlacademy.ru/courses:

https://       — это протокол
htmlacademy.ru — имя сервера, также называется домен или хост
/courses       — путь


В относительных адресах нет ни протокола, ни имени сервера, а путь не начинается со слэша /. Вот примеры относительных адресов:

courses/1
./courses
../../run/1
В относительных адресах могут использоваться специальные символы, аналогичные символам в путях файловых систем: . и ...



Ссылка с якорем содержит символ #, после которого идёт идентификатор. Идентификатор создаётся с помощью атрибута id, который может быть задан у любого тега.
Можно задать адрес, состоящий из одного якоря, например:
<a href="#glava1">Глава 1</a>

Для того, чтобы добавить ссылке всплывающую подсказку, надо использовать атрибут title. Например:
<a title="Подсказка" href="#">

Чтобы добавить на страницу изображение, нужно использовать одиночный тег <img> с атрибутом src, в котором указан адрес картинки. Например:
<img src="logo.png">

Чтобы управлять шириной или высотой изображения, нужно использовать атрибуты width и height. Пример:
<img width="100" src="...">

Альтернативный текст изображения задаётся с помощью атрибута alt. Пример:
<img src="cat.png" alt="Кот в полном расцвете сил">

Ссылки можно делать не только с помощью текста, но и с помощью изображений. Для этого нужно обернуть тег <img> в тег <a>. Например:
<a href="http://keksby.ru">
  <img src="cat.png" alt="Кекс">
</a>

Простейшая таблица описывается с помощью трёх тегов:

<table> обозначает таблицу.
<tr> расшифровывается как «table row», обозначает строку таблицы.
<td> расшифровывается как «table data», обозначает ячейку внутри строки таблицы.
Теги <td> располагаются внутри тегов <tr>, а те, в свою очередь, внутри <table>. Почти всё текстовое содержимое таблицы размещается внутри тегов <td>.
В простейшей таблице в каждой строке должно быть одинаковое количество ячеек, то есть внутри всех <tr> должно быть одинаковое количество <td>.


Таблицы в предыдущих заданиях отображались с рамками по умолчанию. Такие рамки отображаются, если у тега <table> задан атрибут border с ненулевым значением.
Но с помощью атрибута border гибко управлять рамками не получается. С его помощью можно только изменять их толщину.
Поэтому мы будем учиться использовать CSS. С помощью CSS-свойства border можно задавать как внешние рамки таблицы, так и рамки каждой ячейки.

table {
    border: 3px solid black;}
td {
    border: 3px solid lightgray;
}


Чтобы избавиться от таких двойных рамок, используется CSS-свойство таблицы border-collapse. Вот так:
table {
  border-collapse: collapse;
}


Иногда требуется, чтобы рамки ячеек в таблице отображались не полностью. Например, чтобы отображалась только нижняя рамка ячеек,
 тогда таблица получается расчерченной по горизонтали. Аналогично, если отображать только боковые рамки ячеек, то таблица получается разбитой на столбцы.

Такие эффекты легко достигаются с помощью CSS. Для этого необходимо использовать не свойство border, которое задаёт рамки для всех сторон ячейки, 
а одно из свойств:
border-top,

border-right,

border-bottom,

border-left.

Эти свойства задают отображение только одной рамки ячейки: верхней, правой, нижней или левой соответственно.

Вы освоили простейшие приёмы для работы с рамками таблиц. Наша таблица уже смотрится аккуратно, но содержимое ячеек прилипает к рамкам.
 Если добавить отступы внутри ячеек, то информация будет восприниматься намного лучше.
Отступы внутри ячеек можно добавлять с помощью атрибута cellpadding тега <table>. Но лучше его не использовать, а задавать отступы с помощью CSS.
CSS-свойство padding задаёт «внутренние отступы элемента» со всех сторон. Можно задавать отступы для каждой из сторон отдельно, используя свойства:

padding-top,

padding-right,

padding-bottom,

padding-left.


Большинство задач по оформлению таблиц решаются с помощью работы с рамками, отступами внутри ячеек, изменения цвета фона ячеек.
Помимо внутренних отступов можно задавать отступы между ячейками таблицы.
Отступы между ячейками не работают с border-collapse: collapse, что достаточно логично, ведь рамки ячеек в этом режиме «склеены» и их не разорвать.
Поэтому в этом задании мы используем border-collapse: separate, которое «расклеивает» ячейки. На самом деле это значение по умолчанию, а мы 
используем его только для наглядности. Если удалить свойство border-collapse, то результат не изменится, ячейки будут отображаться раздельно.

Отступы между ячейками можно задать:
с помощью атрибута cellspacing тега <table>
или c помощью CSS-свойства border-spacing.
Отметим, что свойство border-spacing задаётся для таблицы, в отличие от padding, которое задаётся для ячеек.


Обычно в таблицах выделяют названия столбцов или строк. В HTML для этого предусмотрен специальный тег <th>, который расшифровывается как «table header» и
 обозначает ячейку-заголовок. 
Тег <th> аналогичен <td>, он так же должен располагаться внутри <tr>,
 для него стилями можно задавать все те же свойства. 
 По умолчанию текст внутри <th> выделяется жирным и выравнивается по центру ячейки.
 
 Сейчас подпись Распределение браузеров сделана с помощью заголовка первого уровня. В принципе, можно догадаться, что это название таблицы, 
 но семантически правильнее будет сделать это название с помощью тега <caption>.
Тег <caption> должен размещаться внутри тега <table>, причём непосредственно внутри него и первым, до остальных вложенных тегов. Вот так:
<table>
  <caption>Текст</caption>
  ...
 </table>
 
 Тег заголовка идёт первым внутри таблицы, но с помощью CSS можно переместить заголовок таблицы в любое место: сверху или снизу таблицы, 
 по центру, справа или слева.
По вертикали заголовок таблицы перемещается CSS-свойством caption-side со значениями top и bottom, которые обозначают до и после таблицы соответственно.
По горизонтали заголовок таблицы выравнивается CSS-свойством text-align со значениями left, right и center.

Начнём с объединения ячеек по горизонтали. Чтобы объединить ячейки по горизонтали, необходимо использовать атрибут colspan у тегов <th> или <td>.
Когда вы задаёте ячейке атрибут colspan со значением 2, то ячейка как бы «растягивается» на ячейку справа, но та ячейка не исчезает, а отодвигается 
и в таблице появляется новый столбец. Чтобы удалить его, 
нужно удалить ячейку, которая находится справа от «растянутой».

Объединение ячеек по вертикали немного сложнее. Оно осуществляется с помощью атрибута rowspan у тега <td> или <th>.

Можно ли объединять более двух ячеек по горизонтали? Можно! При этом точно так же используется атрибут colspan. Однако, так как ячейка «растягивается» вправо больше,
 чем на одну соседнюю ячейку, то и лишних столбцов появляется больше.
 
  Для удобства восприятия ячейки, которые будут вытесняться в каждом из столбцов, помечены разными цветами.
  Вам нужно будет устанавливать свойство rowspan
  
  Можно растягивать ячейку одновременно и по вертикали, и по горизонтали. Для этого нужно задать ячейке два атрибута: rowspan и colspan.
Вытеснение соседних ячеек будет происходить так же, как и при обычном объединении ячеек. Правда, вытесненных ячеек окажется больше. 
Например, ячейка с rowspan="2" и colspan="2" вытеснит три соседних ячейки.


За выравнивание по горизонтали отвечает CSS-свойство text-align. Чаще всего используются значения left, center и right.
За выравнивание по вертикали отвечает CSS-свойство vertical-align. Чаще всего используются значения top, middle и bottom.
td {
  vertical-align: значение;
  text-align: значение;
}

Цветами можно управлять с помощью этих свойств:
background-color — задаёт цвет фона,

color — цвет текста,

border-color — цвет рамок.

До этого мы использовали компактную форму для описания рамок: border: 1px solid lightgray. 
В этой записи цвет задаёт третья часть — lightgray.
td {
  color: цвет;
  background-color: цвет;
  border: 1px solid цвет;
}

Как быть, если стили нужно задать для какой-то определённой ячейки, группы ячеек, или строки? Можно использовать классы и применять стили для этих классов. 
Например, вот так:

.my-class {
  стили
}

Ширина таблицы задаётся с помощью CSS-свойства width, а высота с помощью свойства height, например:

table {
  width: 100px;
  height: 100px;
}

Особое значение auto включает расчёт размеров по умолчанию. Например, width: auto; или height: auto;.
Важное замечание. Проценты при задании высоты обычно не работают.

Есть два варианта добавления стилей ячейкам:
Назначать ячейкам уникальные имена классов, например, class="cell-11", и применять стили для этих классов.
Использовать атрибут style, внутри которого можно писать CSS-код.
Пример второго варианта:

<td style="width: 100px;">
  ...
</td>

             <th style="width: 70%;">Браузер</th>
             <th style="width: 15%;">∑</th>
             <th style="width: 15%;">%</th>
			 
			 
			 
			 Стили для body менять не надо.

Формы заполнения 

Чтобы создать форму, нужно использовать парный тег <form>, внутри которого размещаются поля формы. У тега <form> есть два важных атрибута:
action задаёт адрес, URL, отправки формы;
method задаёт метод отправки формы.
Пример:
<form action="https://echo.htmlacademy.ru" method="get">
  поля формы
</form>
Для отправки формы обычно используют методы get или post. Если не указать атрибут method, то будет использован get.
Метод get посылает данные формы в строке запроса, то есть они видны в адресной строке браузера и следуют после знака вопроса. Например:
https://www.google.com/search?q=htmlacademy
Метод get лучше использовать в поисковых формах, потому что он позволяет получить ссылку на результаты поиска и передать её кому-то.
Метод post посылает данные в теле HTTP-запроса и используется, когда нужно отправить много данных и ссылка на результат обработки 
этих данных не нужна. Например, при редактировании личного профиля.

Большинство полей форм создаётся с помощью одиночного тега input. У этого тега два обязательных атрибута:

type задаёт тип поля;

name задаёт имя поля.

Тип поля влияет на то, как оно будет отображаться и вести себя. Самый распространённый тип — это text, который обозначает текстовое поле. 
Он же используется по умолчанию. Пример:
<form action="https://echo.htmlacademy.ru" method="get">
  <input type="text" name="search">
</form>
Имя поля нужно, чтобы правильно обработать данные на сервере. Обычно, имя поля должно быть уникальным в пределах формы, хотя есть исключения.
 Для задания имени поля используют латинские буквы и цифры.
 
 Атрибут id поля ввода обозначает идентификатор. Он должен быть уникальным не только в пределах формы, но и на всей странице.
Обычно идентификаторы используют для повышения удобства работы с формой, например, создают подписи, связанные с мелкими полями. 
Идентификатор в отличие от имени поля не передаётся на сервер. Лучше использовать идентификаторы, отличающиеся от имени поля, 
особенно актуально это для полей множественного выбора, которые мы разберём далее в курсе.
Атрибут value задаёт значение поля ввода по умолчанию. Это тоже повышает удобство.

Создавать подписи к полям с помощью <label> — хороший приём. Используйте его.
Первый способ создать подпись — просто обернуть текст подписи и тег поля в тег <label>, вот так:
<label>
  Подпись <input type="text" name="username">
</label>

Иногда обернуть поле и текст подписи в тег <label> нельзя. Например, когда они размещены в разных ячейках таблицы.
В этом случае можно связать подпись с полем с помощью атрибута id. Алгоритм такой:
Добавляем к полю ввода идентификатор с помощью атрибута id.
Оборачиваем текст подписи в тег <label>.
Добавляем тегу <label> атрибут for.

В атрибут for записываем такое же значение, что и в атрибуте id у поля.
Например:

<label for="user-field-id">Имя пользователя</label>
...
много-много других тегов
...
<input id="user-field-id" type="text" name="username">
Чтобы сделать его настоящим полем для ввода пароля, в котором текст будет отображаться «звёздочками»,
 нужно просто изменить значение атрибута type на password.
 
 Форма практически готова. Осталось добавить кнопку для отправки формы. Такая кнопка создаётся с помощью тега <input> c типом submit.
Надпись на кнопке можно задать с помощью атрибута value. Для кнопки отправки формы задавать имя необязательно. 
Но если имя задано, то на сервер будут отправляться имя и значение кнопки.

Многострочное текстовое поле создаётся с помощью парного тега <textarea>. У него есть атрибуты name и id, которые аналогичны атрибутам текстового поля.
Атрибут rows принимает целочисленное значение и задаёт высоту многострочного поля в строках. Атрибут cols задаёт ширину поля в символах. 
В качестве ширины символа берётся некоторая «усреднённая ширина».
Атрибут value у многострочного поля отсутствует, а значение по умолчанию задаётся по-другому. Текст, расположенный между открывающим и 
закрывающим тегом <textarea> и является значением по умолчанию. Вот так:
<textarea>Значение по умолчанию</textarea>

Поле-галочка — это тег <input> с типом checkbox.
Чтобы галочка стояла по умолчанию, нужно добавить к тегу атрибут checked. Вот так:

<input type="checkbox" checked>
Чекбокс не подразумевает выбор одного элемента из нескольких. Поэтому если в одной форме есть несколько чекбоксов, то имена у них должны быть разными.

Создайте простейшую форму регистрации с использованием уже изученных полей.

Поле-переключатель — это тег <input> с типом radio.
Таким образом, атрибут value является для переключателей обязательным. Браузер отправляет на сервер значение value выбранного переключателя.
 <input type="radio" name="question-one" value=p></input>
 Чтобы сделать какой-либо вариант в переключателе выбранным по умолчанию, нужно добавить к соответствующему тегу <input> атрибут checked, как у поля-галочки.

 
 Раскрывающийся список создаётся с помощью парного тега <select>, у которого есть знакомые атрибуты name и id.
Варианты ответов задаются с помощью парных тегов <option>, которые должны располагаться внутри тега <select>. Например:
<select name="theme">
  <option value="light">Светлая тема</option>
  <option value="dark">Тёмная тема</option>
  ...
</select>

В атрибуте value тега <option> задаётся значение варианта ответа, а внутри этого тега располагается подпись варианта ответа.
Если при отправке формы у выбранного варианта задан value, то на сервер отправится значение этого атрибута. В противном случае будет отправлен текст подписи.
select name = year>
    <option value = 2000>2000 год </option>
    <option value = 2001>2001 год </option>
</select>
Раскрывающийся список можно превратить в так называемый «мультиселект», то есть список, в котором можно выбрать не один, а несколько вариантов.
Чтобы сделать это, нужно добавить к тегу <select> атрибут multiple.
Выбрать несколько вариантов можно, щёлкая по ним с зажатой клавишей Ctrl на Windows или Command на OS X.
Высоту мультиселекта можно изменять с помощью атрибута size тега <select>.
Чтобы отметить как выбранные по умолчанию одно или несколько значений, нужно к соответствующим тегам <option> добавить атрибут selected.

<select name="days" multiple size=7>
                <option>Понедельник</option>
                <option>Вторник</option>
                <option>Среда</option>
                <option>Четверг</option>
                <option>Пятница</option>
                <option>Суббота</option>
                <option selected>Воскресенье</option>
            </select>
			
Поле для загрузки файлов — это тег <input> с типом file. Для этого поля обязательным атрибутом является имя.
Чтобы поле заработало и браузер смог передать выбранный файл на сервер, необходимо добавить форме атрибут enctype со значением multipart/form-data.
 Не полю, а форме.

 <form action="https://echo.htmlacademy.ru" method="post" enctype="multipart/form-data">
            <p>Выберите изображение для своего аватара:</p>
            <input type=file name=avatar></input>
			
И ещё одно невидимое и очень полезное поле. Это скрытое поле. Его используют, когда в форме нужно отправить какие-то дополнительные служебные данные,
 которые не вводятся пользователем.
Например, это могут быть реквизиты заказа или номер пользователя в форме оплаты.
Скрытое поле — это тег <input> с типом hidden.


Напомним, что CSS расшифровывается как «каскадные таблицы стилей». Этот язык отвечает за внешний вид HTML-страницы. Синтаксис языка достаточно прост: 
он состоит из селекторов и свойств.
С помощью селекторов можно сказать браузеру какие именно элементы мы хотим оформить. Свойства описывают как именно мы хотим оформить эти элементы.

Весь CSS-код состоит из повторяющихся блоков следующего вида:

селектор {
  свойство1: значение;
  свойство2: значение;
}

Простейшие селекторы — это селекторы по именам тегов. С их помощью можно задать стили для всех абзацев на странице, для всех ссылок, заголовков 
первого уровня и так далее. Такие селекторы содержат имя тега без символов < и >. Например:
p {
  /* стили для абзацев */
}

h1 {
  /* стили для заголовков */
}


p   {
    color: #999999;
    }
    
h1  {
    font-family: Tahoma;
    }    
    
h2  {
    color: #0088cc;
    }
	
	
Класс тега можно задать с помощью атрибута class, который содержит имя класса (или имена классов через пробел). Пример:

<p class="help"></p>
<p class="help error"></p>
В примере у первого абзаца задан класс help, у второго абзаца заданы классы help и error.
Селектор с использованием класса задаётся так: .имя_класса. Например:

.help { ... }
.error { ... }

.underline {
    text-decoration: underline;(нижнее подчеркивание текста)
}

.bold {
  font-weight: bold;  (выделение жирным)
}

.italic {
    font-style: italic;(наклонный текст)
}	


Все свойства, которые так или иначе влияют на размеры и отступы элементов, описываются в так называемой «Блочной модели документа». Помимо свойств для отступов 
и размеров в блочную модель входят свойства для описания границ и очень важное свойство display,которое определяет тип элемента (блочный, строчный и другие).

.p-first {
    margin-left: 50px;(отступы слева)
}

.p-second {
    padding: 20px;(отступы внутренние)
}

.p-third {
    width: 50%;(ширина)
}


С помощью позиционирования можно очень точно и гибко управлять расположением элементов. Позиционирование применяют для создания сложных «многослойных» интерфейсов, 
таких как всплывающие окна или галереи, а также для вёрстки мелких декоративных элементов.

Главным свойством для работы с позиционированием является position, которое переключает режимы позиционирования элемента.
 Ещё четыре свойства: top, right, bottom, left, управляют расположением элемента. И последнее свойство z-index управляет порядком слоёв.
 
 .p-absolute {
    padding: 20px;
    background-color: rgba(0, 255, 0, 0.25);
    position: absolute;
    left: 100px;
    bottom: 200px;
}



Типичный веб-сайт состоит из шапки, главного меню, блока с основным содержанием, боковых колонок, подвала. Эти блоки могут быть расположены друг под другом,
 в несколько колонок или ещё сложнее. Такое взаимное расположение основных блоков сайта и называют «сеткой» или «раскладкой».

Сетка может быть фиксированной или тянущейся, когда ширина блоков изменяется в зависимости от ширины браузера. Чтобы быстро и легко создавать сетки, 
нужно хорошо разбираться в блочной модели и позиционировании.
CSS-правило для класса left-column свойство float: left;.
CSS-правило для right-column свойство float: right;.
CSS-правило для footer свойство clear: both;.


Чтобы сделать страницу яркой и красивой можно использовать множество свойств: цвет текста, фон, тени, рамки, закругления и многие другие.

Работа с декоративными свойствами будет подробно рассмотрена в серии курсов и демонстраций, например, в курсах «Фоны» и «Оформление текста с помощью CSS».

В предыдущем примере мы с помощью класса добавили ко второму абзацу дополнительные стили. CSS-правило для абзацев и CSS-правило для класса 
содержали по одному свойству. Когда мы добавили класс ко второму абзацу, в его наборе стилей стало два свойства. Вот так:

p {
  padding: 10px;
}
       +
.truth {
  background-color: #dff0d8;
}
       =
стили второго абзаца {
  padding: 10px;
  background-color: #dff0d8;
}




Когда в предыдущем задании мы задали цвет фона для правила с классом truth, одно из свойств второго абзаца переопределилось:

p {
  padding: 10px;
  background-color: #dff0d8;
}
       +
.truth {
  background-color: #aaddff;
}
       =
стили второго абзаца {
  padding: 10px;  
  background-color: #aaddff;
}



Когда для одного и того же элемента есть несколько CSS-правил с одинаковыми свойствами, браузер использует понятия приоритетов и специфичности, 
чтобы выбрать значение свойства из нескольких возможных. Упрощённо, можно сказать что:

CSS-правила в значении атрибута style самые приоритетные,
за ними идёт селектор с id,
затем селектор с классом,
затем селектор с именем тега.

Когда к одному элементу применяются несколько CSS-правил, то приоритетность этих правил определяется по их селектору. Если селекторы однотипные, 
как в нашем случае, то тогда более приоритетным является CSS-правило, которое расположено ниже в коде.


Другой важный механизм CSS — это наследование. Он заключается в том, что часть стилей может передаваться от родительского элемента к дочерним (вложенным в него).
Например, все элементы внутри тега body являются дочерними по отношению к нему. Если для body в стилях задать цвет текста красным, то цвет всех остальных
 элементов тоже станет красным.
Ещё пример: тег ul является родительским по отношению к вложенным в него тегам li. Если задать для ul шрифт курсивом, то и внутри всех li шрифт станет курсивным

Наследование работает не для всех свойств. Некоторые свойства применяются только к самому элементу и не переходят к его потомкам.
К таким ненаследуемым свойствам относятся: ширина, высота, отступы, режим позиционирования и другие. Согласитесь, было бы странно задать отступы
для body и обнаружить, что у всех вложенных элементов тоже появились отступы.

body {
    padding: 20px;
}

ul {
    border: 1px solid #cccccc;
    padding: 30px;
}


Чтобы исправить макет, нужно добавить недостающие свойства, а некоторые исправить. Все свойства, которые «испорчены» или «потеряны» в прототипе, 
вы использовали в этом курсе:

ширина и внешние отступы,
цвета фона и текста,
начертание и толщина шрифта,
построение сеток.
Подсказки:

Использованные цвета: #ffffff и #333333.
Для одного элемента нужно будет изменить размер шрифта, для этого используйте свойство font-size.
Значения отступов, ширины блоков, а также неизвестных размеров шрифта кратны 10,
Свойства для позиционирования position, top, left и другие не 


С помощью селекторов по именам тегов можно задать стили для всех элементов списка, изображений, абзацев и так далее. 
Эти селекторы содержат имя тега без символов < и >. Например:
li {
  /* стили для элементов списка */
}

<li class="first"></li>
Этот атрибут особенный, так как в CSS существует возможность выбирать элементы по классу. Делается это с помощью такого селектора: .имя_класса. Например:

.first {
  /* стили для класса first */
}


Всего будет три типа выстрелов в мишень, каждому из которых соответствует свой цвет:

Мишень закрыта — background-color: white;
Выстрел мимо — background-color: red;
Ошибка техники (попадание есть, но мишень не закрылась) — background-color: yellow;
Потренируемся использовать классы.

Селектор может состоять из нескольких частей, разделённых пробелом, например:

p strong { ... }
ul .hit { ... }
.footer .menu a { ... }

Такие селекторы называют контекстными или вложенными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.
Например, селектор .menu a сработает для ссылки a только в том случае, если она расположена внутри элемента с классом .menu.

/* выбрать все теги strong внутри тегов p */
p strong { ... }

/* выбрать все элементы с классом .hit внутри тегов ul */
ul .hit { ... }

/* выбрать все ссылки внутри элементов с классом .menu,
   которые лежат внутри элементов с классом .footer */
.footer .menu a { ... }

Например, теги <li> в списке являются соседними по отношению друг к другу и вложенными в тег <ul>.
Соседние селекторы записываются с помощью знака +, например, селектор1 + селектор2. Стили применятся к элементу, подходящему под селектор2,
 только если сразу перед ним расположен элемент, подходящий под селектор1.

<li class="hit"></li>
<li class="miss"></li>

Селектор .hit + .miss применит стили к элементу с классом miss, так как перед ним есть элемент с классом hit.
Селектор .hit + li тоже применит стили к элементу с классом miss, а селектор .miss + .hit не сработает.

Селекторы в CSS можно очень гибко комбинировать. В частности, можно комбинировать контекстные и соседние селекторы.

Например, селектор .player-1 .hit + .miss сработает для тега с классом miss, если сразу перед ним расположен тег с классом hit 
и оба тега расположены внутри тега с классом player-1.

.shooter-1 li{
    background-color:white;
    }
    
.shooter-1 .third+li{
    background-color:red;
    }
    
.shooter-2 li{
    background-color:white;
    }
    
.shooter-2 .first+li{
    background-color:red;
    }
    
.shooter-2 .third+li{
    background-color:yellow;
    }
	
Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:

<ul>
  <li><span>...</span></li>
  <li><span>...</span></li>
</ul>	

По отношению к <ul> <li> являются дочерними элементами и потомками, а <span> — потомки, но не дочерние элементы.

Для этого существует дочерний селектор, в котором используется символ >. Например: ul > li или ul > li > span.

.places > li {
    border-bottom: 2px solid #cccccc;
}

.places > li > span {
    font-weight: bold;
}

Псевдокласс добавляется к селектору c помощью символа :, вот так селектор:псевдокласс. Например:

a:visited { ... }
li:last-child { ... }
.alert:hover { ... }

Знакомство с псевдоклассами мы начнём с first-child и last-child.
Псевдокласс first-child позволяет выбрать первый дочерний элемент родителя, а last-child — последний дочерний элемент. Например:
li:last-child { ... }
Этот селектор выберет последний элемент списка.

li:first-child{
    background-color:red;
    }
    
li{
    background-color:white;
    }    
    
li:last-child{
    background-color:yellow;
    } 
	
С помощью псевдокласса nth-child можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: селектор:nth-child(выражение). 
Выражением может быть число или формула. Например:

1. li:nth-child(2) { ... }
2. li:nth-child(4) { ... }
3. li:nth-child(2n) { ... }	

Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элементы.

li:nth-child(3){
    background-color:red;
    }
li{
    background-color:white;
    }    

li:nth-child(4){
    background-color:red;
    }  
	
Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.

Например, селектор:
.shooter-2 li:nth-child(3) { ... }
Выберет третий тег <li> внутри блока с классом shooter-2.	


.shooter-1 li:nth-child(2){
    background-color:red;
    }
li{
    background-color:white;
    }  
    
.shooter-1 li:nth-child(5){
    background-color:red;
    }    

.shooter-2 li:nth-child(1){
    background-color:red;
    }  
	
Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом :hover.
Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата. Примеры:

1. a:hover { ... }
2. tr:hover { ... }
3 .menu-item:hover { ... }	

tr:hover {
    background-color: #fcf8e3;
}

strong:hover {
    color: #0088cc;
}


сетки


Поток — это порядок отображения элементов на странице. По умолчанию блочные элементы отображаются как прямоугольные области, идущие друг за другом сверху вниз, 
а строчные элементы располагаются сверху вниз и слева направо и при необходимости переносятся на новую строку.
Потоком можно управлять и изменять привычное поведение элементов в потоке. Например, можно заставить блочные элементы двигаться не сверху вниз, а выстраиваться в несколько колонок.
А научившись управлять потоком, вы сможете строить сетки.


.column1 {
    float: left;
    width: 120px;
    min-height: 50px;
}

.column2 {
    float:right;
     width: 120px;
    min-height:50px;
}

.column3{
    clear:both; - убирает наезжание на другие элементы
    width: 150px;
    min-height: 50px;
    margin-right:auto;
    margin-left:auto;
    }
	
А пока вы пошагово создаёте второй поток, поговорим о сетках.
Сетка — это взаимное расположение крупных блоков сайта. Вспомните любой сайт, например, ВКонтакте или HTML Academy.	

Что нужно знать и уметь, чтобы строить сетки? Две вещи:

управлять размерами элементов;
управлять поведением элементов в потоке.
Первая часть детально разбирается в курсе «Блочная модель документа». Там вы учитесь:

задавать размеры;
рамки;
внешние и внутренние отступы;
рассчитывать полный размер элемента;
рассчитывать занимаемую им площадь.
Управлять поведением в потоке мы будем учиться в этом курсе.

.column1 {
    float: left;
    width: 65px;
    min-height: 50px;
    margin-right: 9px;
}

.column2 {
    float: left;
    width: 80px;
    min-height: 50px;
}

.column3 {
    float:right;
    width: 65px;
    min-height: 50px;
    
}

Существует несколько способов управлять потоком и строить сетки:

флоаты;
инлайн-блоки;
табличная вёрстка;
флексбоксы.
Табличная вёрстка — самый простой для понимания способ построения сеток. Но он считается устаревшим и использовать его не рекомендуется. 
В будущем можно будет использовать для такой вёрстки не таблицы, а элементы с display: table, display: table-row и display: table-cell.
Флексбоксы — это новая и очень мощная технология для построения сеток. К сожалению, её поддержка браузерами ещё достаточно слабая.
А флоаты и инлайн-блоки мы разберём в этом курсе более подробно. Основной упор сделаем на флоаты, т. к. сейчас это самый распространённый способ построения сеток.

То есть, можно сказать, что float — это свойство, включающее режим обтекания. Но, как часто бывает, судьба уготовила ему совсем другую роль.
Свойство float имеет следующие значения:

left — прижимает элемент к левому краю родителя, другие элементы обтекают его справа;
right — прижимает элемент к правому краю родителя, другие элементы обтекают его слева;
none — отключает режим обтекания и возвращает элементу нормальное поведение.


Вы уже знаете, что по умолчанию блочные элементы растягиваются на всю доступную ширину родителя.
Если мы задаём элементу свойство float:left или float:right, то он прижимается к левому или правому краю, а также начинает ужиматься по ширине под своё содержимое. 
С той стороны, которая не прижата к краю родителя, появляется свободное место. Это место может быть занято другими элементами.
Зафлоаченному элементу можно явно задавать размеры и отступы.
Есть тонкость, связанная со строчными элементами. Если зафлоатить строчный элемент, то он начинает вести себя как блочный, а именно: воспринимать размеры и отступы.

Мы уже говорили про выпадание элементов из потока, когда разбирали абсолютное и фиксированное позиционирование.

Зафлоаченные элементы тоже выпадают из потока, но лишь частично:

Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.
Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.
Ещё раз: для блочных элементов флоатные не существуют, но текст внутри блоков флоатные обтекает.
Такое поведение флоатов даёт интересные эффекты:

Эффект прохождения сквозь блоки. Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.
Эффект выпадания из родителя или схлопывания родителя. Проявляется тогда, когда все дочерние блоки в родителе зафлоачены. В этом случае родитель схлопывается по высоте,
 как будто в нём нет содержимого, а блоки выпадают из него.
 
 Следует отметить, что поведение нескольких флоатов, когда им не хватает места в одной строке, является очень странным.
Когда не влезающий флоат переносится на новую строку, возможно несколько вариантов и не все из них логичны. Например, флоат может «зацепиться» 
за один из предшествующих флоатов и встать ниже не в самом начале строки, а за предшествующим.
В этом упражнении примеры специально подобраны так, чтобы вы увидели странности поведения флоатов при недостатке места.
Естественно, эти особенности повлияли на приёмы использования флоатов в создании раскладок (еще одно название для сеток). Но об этом позже.


Свойство clear запрещает обтекание элемента другими элементами. Вот его значения:

left — запрещено обтекание слева;
right — запрещено обтекание справа;
both — запрещено обтекание с обеих сторон;
none — обтекание разрешено.
Если после флоатного элемента расположен элемент с запрещённым обтеканием, то последний опускается под флоатный.

Свойство clear учит блочные элементы «видеть» зафлоаченные


Необходимо было найти способ борьбы с выпаданием. Тут и пригодилось свойство clear:both. Стали применять такую структуру:

<div class="container"> - блок-контейнер
    <div class="column1">...</div> - колонка, флоат
    <div class="column2">...</div> - колонка, флоат
    <div class="clearfix"></div> - распорка с clear:both
</div>
Т. е. начали добавлять после зафлоаченных колонок пустой элемент-распорку со свойством clear:both. Этот элемент видел колонки, не давал им пройти через себя, а заодно и растягивал родительский блок по высоте.

Для таких распорок прижилось специальное название класса — clearfix.



Хорошие верстальщики не очень любят, когда в вёрстке появляются ненужные дополнительные элементы и стараются от них избавляться.
До поры до времени с блоками-распорками приходилось мириться, т. к. без них было никак не обойтись. Но время шло и в браузерах появилась поддержка так называемых псевдоэлементов.
Псевдоэлементы позволяют с помощью CSS вставить в структуру HTML-документа узлы, которых нет в HTML коде. Т. е. можно вставить в код элемент и 
не писать его в HTML. Благодаря псевдоэлементам появилось решение проблемы флоатов без использования дополнительного элемента.
Назовём это решение псевдораспорками. Есть несколько его вариаций, но вот одна из распространённых. В CSS добавляется следующее правило:

.clearfix::after {
    content: "";
    display: table;
    clear: both;
}
А затем класс clearfix добавляется к контейнеру, внутри которого лежат флоатные колонки. После этого в контейнер не нужно добавлять дополнительный элемент-распорку, 
т. к. распорка создаётся с помощью псевдоэлемента.

