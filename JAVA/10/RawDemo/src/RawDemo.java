// пример использования "базовых типов" для старого кода

// обобщенный класс ("новый" код)
class Gen<T> {
  T ob; // внутренняя переменная типа T

  // простой конструктор
  Gen(T o) {
    ob = o;
  }

  // возвращаем содерживое ob.
  T getob() {
    return ob;
  }
}


// демокласс
class RawDemo {
public static void main(String args[]) {

 // новый код:
 // создаем Gen-объект для Integer и String (обобщенные объекты)
 Gen<Integer> iOb = new Gen<Integer>(88);
 Gen<String> strOb = new Gen<String>("Тест обобщений");

 
 // унаследованный код:
 // создаем непараметризованный вариант объекта Gen ("базовая ссылка" - фактически ссылка на Object)
 // и помещаем туда объект Double
 Gen raw = new Gen(new Double(98.6));

 // проблема 1: при дальнейшем использовании нужно ручное приведение типов!
 double d = (Double) raw.getob();
 System.out.println("Значение: " + d);

 // проблема 2: возможны run-time исключения
 // int i = (Integer) raw.getob(); // получим ошибку из-за несоответствия типоа

 // сомнительная операция - но компилятор пропустит (т.к. Object совместим с любыми классами)
 strOb = raw; 
 // а вот при попытке использования содержимого - получим ошибку из-за несоответствия типоа
 // String str = strOb.getob(); 

 // аналогичная проблема - см. примечание выше
 raw = iOb; // компилятор пропустит
 // d = (Double) raw.getob(); // а здесь уже будет ошибка исполнения
}
}