// пример простого лямбда-выражения

// пример ФИ без параметров
interface MyNumber {
  // единственный (и абстрактный) метод
  double getValue();
}

// ФИ с параметром (одним)
interface NumericTest {
	boolean test(int n);
}

// ФИ с двумя int-параметрами и boolean-результатом 
interface NumericTest2 {
	  boolean test(int n, int d);
	}


// демокласс
class LambdaDemo {
  public static void main(String args[])
  {
    MyNumber myNum;  // ссылка на интерфейс без параметров

    // лямбда-выражение в данном случае - это просто константное выражение
    // (нет входных параметров и возвращаем всегда одно и то же)
    
    // при присваивании выражения ссылке myNum автоматически происходит следующее:
    // 1. создается экземпляр анонимного класса, реализующего интерфейс myNum
    // (объектов самого-то myNum быть не может, т.к. это интерфейс - т.е. абстрактный класс)
    // 2. код лямбда-выражения помещается в метод getValue()
    // ЗЫ откуда компилятор знает, в какой именно метод помещать код ЛВ? А других нет )
     myNum = () -> 123.45;

    // вызывая getValue(), мы фактически запускаем код лямбда-выражения
    System.out.println("Фикс-значение: " + myNum.getValue());

    // теперь переприсваем нашу ссылку на ИФ другому ЛВ 
    // (теперь у getValue() автоматически другая реализация)
    myNum = () -> Math.random() * 100;

    // и вызываем его
    System.out.println("Случайное значение: " + myNum.getValue());
    System.out.println("Еще одно случайное значение: " + myNum.getValue());

    // обратите внимание: лямбда-выражение должно быть совместимо
    // по входным параметрам и возвращаемому значению с методом ФИ 
    //  myNum = () -> "123.03"; // ошибка!!! вместо double в ЛВ возвращается String
    
    
    // теперь поработаем с параметрами
    // метод ФИ получает целое значение, возвращает логическое
    // ЛВ делает то же самое (определяя четность полученного числа)
    // тип параметра выводится из контекста (в данном случае, из объявления метода)
    NumericTest isEven = (n) -> (n % 2)==0;
    // вызываем метод для конкретного значения
    int k = 10;
    if(isEven.test(k)) {
    	System.out.println(k + " четное");
    }
    else {
    	System.out.println(k + " нечетное");
    	}
    
    // переопределяем метод - теперь проверяем число на отрицательность
    // (требования к параметром и возвращаемому значению те же)
    NumericTest isNonNeg = (n) -> n >= 0;
    // и проверяем его работу
    if(isNonNeg.test(k)) {
    	System.out.println(k + " не отрицательное");
    }
    else
    {
    	System.out.println(k + " отрицательное");
    }
    

    
    // пример ФИ и ЛВ с двумя int-параметрами и boolean-результатом
    // типы параметров выводятся из контекста (в данном случае, из объявления метода)
    NumericTest2 isFactor = (n, d) -> (n % d) == 0;
    
    int l = 2;
    if(isFactor.test(k, l)) {
      System.out.println(l + " - множитель " + k);
    }
    else
    {
      System.out.println(l + " - не множитель " + k);
      }
  }
}