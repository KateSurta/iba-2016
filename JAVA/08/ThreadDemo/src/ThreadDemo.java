// класс для реализации потока исполнения
class NewThread implements Runnable {
  // переменная потока исполнения
  Thread t;

  // конструктор - в нем создаем сам поток
  NewThread() {
	// создаем объект потока на основе текущего класса и задаем ему имя
	// а потом помещаем указатель на него в переменную t
    t = new Thread(this, "Demo Thread");
    // выводим информацию о порожденном потоке..
    System.out.println("Дочерний поток: " + t);
    // ..и запускаем его (метод start запускает метод run)
    // сразу после этого управление передается в главный поток,
    // после чего (в многоядерной системе) главный и дочерний поток работают параллельно
    t.start(); 
  }

  // сам код дочернего потока и точка входа в него
  public void run() {
    try {
      // уже знакомый "обратный отсчет с засыпанием"
      for(int i = 5; i > 0; i--) {
        System.out.println("Дочерний поток: " + i);
        Thread.sleep(500);
      }
    } catch (InterruptedException e) {
      System.out.println("Дочерний поток прерван");
    }
    // все нормально - выводим сообщение
    System.out.println("Дочерний поток завершен");
  } 
  
}


// непосредственно демонстрационный класс
class ThreadDemo {
  public static void main(String args[ ] ) {
	// создаем новый поток
    new NewThread(); 

    // запускаем параллельный отсчет в главном потоке
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Главный поток: " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {

      System.out.println("Главный поток прерван");
    }
    // главный поток должен завершиться последним
    // в данном случае это гарантируется разными аргументами метода sleep
    System.out.println("Главный поток завершен");
  }
}